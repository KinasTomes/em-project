          await this.handleReleaseRequest(data);
          break;
        case "RESTOCK":
          await this.handleRestockRequest(data);
          break;
        default:
          logger.warn(`[Inventory] Unknown inventory event type: ${type}`);
      }
    } catch (error) {
      logger.error(
        `[Inventory] Error handling inventory event: ${error.message}`
      );
    }
  }

  /**
   * Handle product created event - Initialize inventory
   */
  async handleProductCreated(data) {
    try {
      const { productId } = data;
      // Prefer 'available' (new contract), fallback to legacy 'initialStock'
      const rawAvailable =
        typeof data.available !== "undefined"
          ? data.available
          : typeof data.initialStock !== "undefined"
          ? data.initialStock
          : undefined;

      const parsed = Number(rawAvailable);
      const effectiveAvailable =
        Number.isFinite(parsed) && parsed >= 0 ? Math.floor(parsed) : 0;

      if (
        rawAvailable !== undefined &&
        Number(rawAvailable) !== effectiveAvailable
      ) {
        logger.warn(
          `[Inventory] Normalized available value '${rawAvailable}' for product ${productId} -> ${effectiveAvailable}`
        );
      }

      logger.info(
        `[Inventory] Handling PRODUCT_CREATED event for ${productId} with available ${effectiveAvailable}`
      );

      await inventoryService.createInventory(productId, effectiveAvailable);
      logger.info(
        `[Inventory] Initialized inventory for product ${productId} with available ${effectiveAvailable}`
      );
    } catch (error) {
      logger.error(
        `[Inventory] Error handling PRODUCT_CREATED: ${error.message}`
      );
      // Don't throw - just log error and continue
    }
  }

  /**
   * Handle product deleted event - Clean up inventory
   */
  async handleProductDeleted(data) {
    try {
      const { productId } = data;
      logger.info(
        `[Inventory] Handling PRODUCT_DELETED event for ${productId}`
      );

      await inventoryService.deleteInventory(productId);
      logger.info(`[Inventory] Deleted inventory for product ${productId}`);
    } catch (error) {
      logger.error(
        `[Inventory] Error handling PRODUCT_DELETED: ${error.message}`
      );
    }
  }

  /**
   * Handle inventory reserve request
   */
  async handleReserveRequest(data) {
    try {
      const { productId, quantity, orderId } = data;
      logger.info(`[Inventory] Handling RESERVE request for order ${orderId}`);

      const result = await inventoryService.reserveStock(productId, quantity);

      // Publish response back to order service (orders queue with response type)
      if (result.success) {
        await this.publishMessage("orders", {
          type: "INVENTORY_RESERVED",
          data: {
            orderId,
            productId,
            quantity,
            success: true,
          },
          timestamp: new Date().toISOString(),
        });
      } else {
        await this.publishMessage("orders", {
          type: "INVENTORY_RESERVE_FAILED",
          data: {
            orderId,
            productId,
            quantity,
            reason: result.message,
          },
          timestamp: new Date().toISOString(),
        });
